{"version":3,"sources":["serviceWorker.ts","index.tsx","app/App.tsx"],"names":["Boolean","window","location","hostname","match","ReactDOM","render","App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message","state","data","loading","canvasRef","React","createRef","canvasContext","this","current","getContext","className","type","onChange","event","setState","files","currentTarget","file","fileReader","FileReader","onloadend","result","ArrayBuffer","byteLength","uintBuffer","Uint8ClampedArray","Buffer","toString","onerror","readAsArrayBuffer","value","e","target","src","style","padding","Component"],"mappings":"oMAYoBA,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCbNC,IAASC,OAAO,kBAACC,EAAA,EAAD,MAASC,SAASC,eAAe,SDsI3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,a,mGE9ItBZ,G,iNACJa,MAAQ,CACNC,KAAM,GACNC,SAAS,G,EAEXC,UAAYC,IAAMC,Y,EAClBC,mB,qFAGMC,KAAKJ,UAAUK,UACjBD,KAAKD,cAAgBC,KAAKJ,UAAUK,QAAQC,WAAW,S,+BASjD,IAAD,SACmBF,KAAKP,MAAvBC,EADD,EACCA,KAAMC,EADP,EACOA,QACd,OACE,yBAAKQ,UAAU,OACb,4BAAQA,UAAU,WAElB,6BAASA,UAAU,QACjB,yBAAKA,UAAU,WACb,2CACA,2BAAOC,KAAK,OAAOC,SAAU,SAACC,GAC5B,EAAKC,SAAS,CACZZ,SAAS,IAF2B,IAI9Ba,EAAUF,EAAMG,cAAhBD,MACR,GAAIA,GAASA,EAAM,GAAI,CACrB,IAAME,EAAOF,EAAM,GAEbG,EAAa,IAAIC,WACvBD,EAAWE,UAAY,WACrB,GAAIF,EAAWG,kBAAkBC,YAAa,CACzBJ,EAAWG,OAAOE,WAArC,IACMC,EAAa,IAAIC,kBAAkBP,EAAWG,QAGpD,EAAKP,SAAS,CACZZ,SAAS,EACTD,KAAM,IAAIyB,EAAOF,GAAYG,SAAS,cAI5CT,EAAWU,QAAU,WACnB,EAAKd,SAAS,CACZZ,SAAS,KAGbgB,EAAWW,kBAAkBZ,OAGjC,2BAAON,KAAK,SAASmB,MAAM,eAE7B,yBAAKpB,UAAU,YACXT,GAAQC,EACR,kBAAC,WAAD,KACE,4BAAMD,EAA8B,aAAvB,uBAEf,kBAAC,WAAD,KACE,0CACA,8BAAU6B,MAAO7B,EAAMW,SAAU,SAACmB,GAChC,IAAM9B,EAAO8B,EAAEC,OAAOF,MACtB,EAAKhB,SAAS,CACZb,YAIJ,yBAAKS,UAAU,gBAAgBuB,IAAG,gCAA2BhC,QAYrE,yBAAKiC,MAAO,CAACC,QAAS,QACpB,6CACA,0DAC2B,6BAD3B,yDAEwD,6BAFxD,yCAGwC,6BAHxC,2CAI0C,oC,GA3FlCC,cAmGHjD,Q","file":"static/js/main.dcfd3ce6.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './app/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React, { Component, Fragment } from 'react';\nimport './App.scss';\n\nclass App extends Component {\n  state = {\n    data: \"\",\n    loading: false\n  }\n  canvasRef = React.createRef<HTMLCanvasElement>();\n  canvasContext?: CanvasRenderingContext2D | null;\n\n  componentDidMount() {\n    if (this.canvasRef.current) {\n      this.canvasContext = this.canvasRef.current.getContext(\"2d\")\n    }\n  }\n\n  // handleBitmap = (bpm:ImageBitmap)=>{\n  //   if(!this.canvasContext) return;\n  //   this.canvasContext.putImageData()\n  // }\n\n  render() {\n    const { data, loading } = this.state;\n    return (\n      <div className=\"app\">\n        <header className=\"header\">\n        </header>\n        <section className=\"main\">\n          <div className=\"actions\">\n            <h3>Choose File</h3>\n            <input type=\"file\" onChange={(event) => {\n              this.setState({\n                loading: true\n              })\n              const { files } = event.currentTarget;\n              if (files && files[0]) {\n                const file = files[0];\n\n                const fileReader = new FileReader();\n                fileReader.onloadend = () => {\n                  if (fileReader.result instanceof ArrayBuffer) {\n                    const byteLength = fileReader.result.byteLength\n                    const uintBuffer = new Uint8ClampedArray(fileReader.result);\n                    // const canvas = this.canvasRef.current;\n\n                    this.setState({\n                      loading: false,\n                      data: new Buffer(uintBuffer).toString('base64')\n                    })\n                  }\n                }\n                fileReader.onerror = () => {\n                  this.setState({\n                    loading: false,\n                  })\n                }\n                fileReader.readAsArrayBuffer(file);\n              }\n            }} />\n            <input type=\"submit\" value=\"Transpile\" />\n          </div>\n          <div className=\"display\">\n            {!data || loading ?\n              <Fragment>\n                <h1>{!data ? \"No content loaded.\" : \"Loading...\"}</h1>\n              </Fragment> :\n              <Fragment>\n                <h3>Transpiled</h3>\n                <textarea value={data} onChange={(e) => {\n                  const data = e.target.value;\n                  this.setState({\n                    data\n                  });\n                }}></textarea>\n                {/* <a download href={`data:image/png;base64,${data}`}>OPEN NEW TAB</a> */}\n                <img className=\"display-image\" src={`data:image/png;base64,${data}`} />\n\n                {/* <button onClick={() => {\n                window.open(`data:image/png;base64,${data}`, \"_blank\")\n              }}>OPEN</button> */}\n\n                {/* <iframe src={`data:application/pdf;base64,${data}`} className=\"display-image\" frameBorder=\"0\"></iframe> */}\n              </Fragment>}\n\n            {/* <canvas ref={this.canvasRef}></canvas> */}\n          </div>\n        </section>\n        <div style={{padding: \"1em\"}}>\n          <h1>NODEJS CODE: </h1>\n          <code>\n            const fs = require(\"fs\");<br/>\n            const data = fs.readFileSync(\"./text.txt\").toString();<br/>\n            let buff = new Buffer(data, 'base64');<br/>\n            fs.writeFileSync(\"./output.data\", buff);<br/>\n          </code>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n"],"sourceRoot":""}